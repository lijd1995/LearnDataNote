<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>程序员俊达-开源笔记</title>
    <link>https://newzone.top/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Mon, 01 May 2023 07:25:48 GMT</pubDate>
    <lastBuildDate>Mon, 01 May 2023 07:25:48 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>博客</category>
    <category>计算机网络</category>
    <item>
      <title>Docker的基本操作</title>
      <link>https://newzone.top/_posts/2023-05-01-Docker%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</link>
      <guid>https://newzone.top/_posts/2023-05-01-Docker%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</guid>
      <source url="https://newzone.top/rss.xml">Docker的基本操作</source>
      <category>博客</category>
      <category>计算机网络</category>
      <pubDate>Mon, 22 Aug 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="docker-下面的一些常用命令" tabindex="-1"> Docker 下面的一些常用命令</h1>
<h2 id="拉取容器" tabindex="-1"> 拉取容器</h2>
<p>docker 安装 ubuntu</p>
<div><pre><code>docker pull ubuntu:20.04
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="启动容器" tabindex="-1"> 启动容器</h2>
<p>启动一个基于 ubuntu:latest 镜像构建，并且名字为 <code>gorden5566</code> 的容器，加上名字是为了以后查看或操作方便。</p>
<div><pre><code>docker run -itd --name gorden5566 ubuntu:latest
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="查看容器是否启动成功" tabindex="-1"> 查看容器是否启动成功</h2>
<p>可通过如下命令查看是否启动成功</p>
<div><pre><code>docker ps
</code></pre><div aria-hidden="true"><div></div></div></div><p>输出的内容格式如下</p>
<div><pre><code>ded0f1381e6c   2bf9cad791e7             "bash"                   28 hours ago    Up 28 hours                             gorden5566
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="连接到容器" tabindex="-1"> 连接到容器</h2>
<p>执行如下命令连接到刚创建的容器</p>
<div><pre><code>docker exec -it gorden5566 /bin/bash
</code></pre><div aria-hidden="true"><div></div></div></div><p>由于 bash 使用上不够便捷，我选择安装了 fish，之所以不选择 zsh 是因为还要安装 oh-my-zsh，比较麻烦</p>
<div><pre><code>apt install fish
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样后续就可以使用 fish 作为默认 shell</p>
<div><pre><code>docker exec -it gorden5566 /usr/bin/fish
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="删除容器" tabindex="-1"> 删除容器</h2>
<p>删除容器的操作步骤如下：</p>
<ol>
<li>停止容器</li>
</ol>
<div><pre><code>docker stop gorden5566
</code></pre><div aria-hidden="true"><div></div></div></div><ol start="2">
<li>删除容器</li>
</ol>
<div><pre><code>docker rm gorden5566
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="赋予-root-权限" tabindex="-1"> 赋予 root 权限</h2>
<p>使用 <code>--privileged</code> 命令赋予容器真正的 root 权限</p>
<div><pre><code>docker run -itd --privileged --name gorden5566 gubuntu

</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="安装命令" tabindex="-1"> 安装命令</h2>
<p>默认安装的 ubuntu 是经过精简的，需要安装命令</p>
<div><pre><code>apt-get update
//ifconfig 
apt install net-tools       
//ping
apt install iputils-ping 
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>没有的命令也可以通过 apt install 进行安装</p>
<p>https://blog.csdn.net/jiankunking/article/details/60466652</p>
<h2 id="打包镜像" tabindex="-1"> 打包镜像</h2>
<p>容器中安装了所需命令，并且按照个人习惯进行了设置，可以打包成一个镜像，后续根据这个镜像创建新的容器。</p>
<div><pre><code>docker commit -m "first commit" -a "gorden5566" gorden5566 gubuntu
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>-m &quot;first commit&quot;</code> 表示本次提交的注释为 <code>first commit</code>
<code>-a &quot;gorden5566&quot;</code> 表示作者为 <code>gorden5566</code></p>
<p>后面一个 gorden5566 表示要打包的镜像名，这里也可以使用 docker ps 看到的容器 id</p>
<p>gubuntu 表示新镜像的名字，此时生成的版本为 <code>gubuntu:latest</code>，也可以在生成时指定版本号，例如 <code>gubuntu:0.0.1</code></p>
<p>后续的启动容器命令</p>
<div><pre><code>docker stop gorden5566

docker rm gorden5566

docker run -itd --privileged --ulimit memlock=-1 --mount type=bind,src=/Users/gorden5566/github,dst=/github --name gorden5566 gubuntu	

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="快速链接到容器" tabindex="-1"> 快速链接到容器</h2>
<p>每次执行 <code>docker exec</code> 命令比较麻烦，可以配置为 alias 以简化操作。如下是在本地主机的 .zshrc 中新增的配置。</p>
<div><pre><code>alias gubuntu="docker exec -it gorden5566 /usr/bin/fish"
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="docker-删除镜像文件" tabindex="-1"> docker 删除镜像文件</h2>
<p><a href="https://www.freecodecamp.org/chinese/news/how-to-remove-images-in-docker/" target="_blank" rel="noopener noreferrer">如何删除 Docker 镜像和容器</a></p>
<p><code>docker rmi</code> 通过镜像的 ID 删除镜像。</p>
<p>要删除镜像，首先需要列出所有镜像以获取镜像的 ID，镜像的名称和其他详细信息。 运行简单的命令 <code>docker images -a</code> 或 <code>docker images</code>。</p>
<p>之后，明确要删除哪个镜像，然后执行简单命令 <code>docker rmi &lt;your-image-id&gt;</code>。然后，列出所有镜像并检查，可以确认镜像是否已删除。</p>
<h2 id="上传镜像到远程仓库" tabindex="-1"> 上传镜像到远程仓库</h2>
<p><a href="https://blog.csdn.net/javaee_gao/article/details/122053127" target="_blank" rel="noopener noreferrer">docker 入门之提交镜像到远程仓库</a></p>
<p><a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">仓库地址</a></p>
<p>这个有点类似于 Maven 的镜像仓库，所以为啥 Docker 能火，Maven 也能火，就是快捷，方便，才够持久。</p>
<p>用户名：lijunda1995</p>
<h3 id="linux-服务器登录-docker-hub" tabindex="-1"> Linux 服务器登录 Docker Hub</h3>
<p>可以通过命令行的方式执行 <strong>docker <code>login</code></strong> 输入用户名与密码，登陆成功后会默认保存我们的认证信息,首先查看命令的使用帮助：</p>
<div><pre><code>[root@VM-0-10-centos ~]# docker login --help

Usage:  docker login [OPTIONS] [SERVER]

Log in to a Docker registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>docker login – username 用户名 服务器地址(可以不填模式就是Docker Hub地址)</p>
<div><pre><code>## 登陆
docker login -u lijunda1995
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="打包镜像-1" tabindex="-1"> 打包镜像</h3>
<p>docker commit -a 用户 -m 提交信息 容器id dockerhub用户名/仓库:标签</p>
<div><pre><code>
## 查看tomcat进程
[root@VM-0-10-centos ~]# docker ps | grep tomcat
b9dec6aec9dc   tomcat    "catalina.sh run"        19 minutes ago   Up 15 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   my-tomcat

## 将运行中的tomcat打包成镜像
docker commit -m 'commit my-tomcat' -a 'GalenGao' b9dec6aec9dc galengao/my-tomcat:v1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="上传镜像" tabindex="-1"> 上传镜像</h3>
<div><pre><code>## docker push dockerhub用户名/镜像:标签
docker push galengao/my-tomcat:v1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="查看镜像" tabindex="-1"> 查看镜像</h3>
<p><a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">登录网址</a></p>
<h2 id="从-docker-下载文件" tabindex="-1"> 从 Docker 下载文件</h2>
<p>通过 cp 指令下载</p>
<p>docker cp 容器id:容器文件路径 本地路径</p>
<div><pre><code>docker cp ecef8319d2c8:/root/test.txt /root/

</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>容器 id 通过 docker ps 进行查看</p>
]]></content:encoded>
    </item>
    <item>
      <title>Wireshark 看这一篇就够了</title>
      <link>https://newzone.top/_posts/2023-05-01-Wireshark%E7%9C%8B%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86.html</link>
      <guid>https://newzone.top/_posts/2023-05-01-Wireshark%E7%9C%8B%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86.html</guid>
      <source url="https://newzone.top/rss.xml">Wireshark 看这一篇就够了</source>
      <category>博客</category>
      <category>计算机网络</category>
      <pubDate>Mon, 22 Aug 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>#wireshark #计算机网络 #网络</p>
<h1 id="wireshark-的使用手册" tabindex="-1"> Wireshark 的使用手册</h1>
<h2 id="wireshark-抓包分析" tabindex="-1"> Wireshark 抓包分析</h2>
<p>通过 tcpdump 生成 pcap 文件，通过 wireshark 打开后，可以看到三次握手进行连接的建立，可以进行分析了。</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304251434170.png" alt="image.png" loading="lazy"></p>
<p>这里面涉及到 wireshark 的一些基本信息查看和命令的使用。</p>
<h2 id="wireshark-时序图" tabindex="-1"> wireshark 时序图</h2>
<p>Statistics -&gt; TCP Stream Graphs -&gt; Time Sequence</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304251451604.png" alt="image.png" loading="lazy"></p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304251451351.png" alt="image.png" loading="lazy"></p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304251454535.png" alt="image.png" loading="lazy"></p>
<p><a href="https://www.wireshark.org/docs/wsug_html_chunked/ChStatTCPStreamGraphs.html" target="_blank" rel="noopener noreferrer">这几个分别标识下面几个含义</a></p>
<p>Time Sequence (Stevens) 和 Time Sequence (tcptrace)</p>
<p>前者更加简单，后者包含（前向段、确认、选择性确认、反向窗口大小和零窗口）</p>
<p>Throughput：平均吞吐量和吞吐量。</p>
<p>Round Trip Time 往返时间 ：往返时间 vs 时间或序列号。 RTT 基于对应于特定段的确认时间戳。</p>
<p>Window Scaling：窗口大小和未完成的字节数。</p>
<h3 id="wireshark的tcptrace图" tabindex="-1"> Wireshark的tcptrace图</h3>
<p>https://blog.csdn.net/dog250/article/details/53227203</p>
<p>这个文章很不错，我觉得应该还有更好的，但这个就已经不错了。</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261501207.png" alt="image.png" loading="lazy"></p>
<p>绿线（接收先）：接收端窗口的序列号 / 时间线
蓝线（发送线）：发送端发送数据的序列号 / 时间线
灰线（ACK线）：接收端应到达发送端的序列号 / 时间线</p>
<h3 id="tcptrace-图解详情" tabindex="-1"> tcptrace 图解详情</h3>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261503080.png" alt="image.png" loading="lazy"></p>
<p>这里面可以看到几点：</p>
<ol>
<li>RTT：平行于time轴连线发送线与ACK线（wireshark 也提供 RTT 的图，可以与 tcptrace 图进行切换）</li>
<li>通过发送线与 ACK 线之间判断关系
<ol>
<li>斜率等于 ACK 线，无队列，RTT 恒定</li>
<li>斜率大于 ACK 线，产生队列，RTT 增大（产生队列拥塞）</li>
<li>随着 RTT 逐步增大，队列也在增大</li>
<li>斜率小于ACK线，主动缓解，持续下去，等与理想发送线相交时，队列排空（拥塞缓解与消除）</li>
</ol>
</li>
</ol>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/12922927.html" target="_blank" rel="noopener noreferrer">wireshark</a></p>
<h2 id="wireshark-常见异常报文分析" tabindex="-1"> Wireshark 常见异常报文分析</h2>
<p>通过 wireshark 可以看到一些问题 <a href="https://zhuanlan.zhihu.com/p/546465303" target="_blank" rel="noopener noreferrer">wireshark TCP常见异常报文分析</a></p>
<h3 id="tcp-window-full" tabindex="-1"> TCP Window Full</h3>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261551533.png" alt="image.png" loading="lazy"></p>
<p>TCP Window Full 接收方接收缓冲区满了后，导致发送方的发送缓冲区装满待确认数据，此时发送方会发送一个TCP Window Full消息。</p>
<h3 id="tcp-zero-window" tabindex="-1"> TCP Zero Window</h3>
<p>TCP Zero Window 是谁发送表示谁的 socket 缓冲区满了没有读。传输过程中，接收方TCP窗口满了，win=0，wireshark会打上 <strong>TCP ZeroWindow</strong> 标签。</p>
<p>基本上就像我们上面设置的一样，差不多每 100ms 都会出现这个问题。</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261636585.png" alt="image.png" loading="lazy"></p>
<h3 id="tcp-window-update" tabindex="-1"> TCP window update</h3>
<p>当接收端接收窗口大小发生变化，可以接收数据了，这个时候接收方接收数据，从win=0逐渐变大，会打上 TCP window update 标签</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261557699.png" alt="image.png" loading="lazy"></p>
<h3 id="tcp-previous-segment-not-captured" tabindex="-1"> TCP Previous segment not captured</h3>
<p>指的是在TCP发送端传输过程中，该Seq前的报文缺失了。一般在网络拥塞的情况下，造成TCP报文乱序、丢包时，会出现该标志。</p>
<p>需要注意的是，TCP Previous segment not captured 解析文字是 wireshark 添加的标记，并非TCP报文内容。</p>
<p>正常计算下一个 seq 应该是 570530，而这个 seq 是 574874，所以中间包丢失了。</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261604492.png" alt="image.png" loading="lazy"></p>
<h3 id="tcp-out-of-order" tabindex="-1"> TCP Out-Of-Order</h3>
<p>TCP发送端传输过程中报文乱序了</p>
<p>继续上面的，我们在 Seq = 574874 前面应该还有一个 Seq = 570530 的包</p>
<p>如果因为网络拥塞的情况下，TCP 包不能按照顺序到达，所以会出现  <strong>TCP Out-Of-Order</strong></p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261608052.png" alt="image.png" loading="lazy"></p>
<h3 id="tcp-spurious-retransmission" tabindex="-1"> TCP Spurious Retransmission</h3>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261614158.png" alt="image.png" loading="lazy">
<a href="https://blog.packet-foo.com/2013/06/spurious-retransmissions/comment-page-1/" target="_blank" rel="noopener noreferrer">spurious-retransmissions</a></p>
<p>虚假重传，就是已经 ACK 的数据，又重传了一遍。这是因为发送方认为数据包丢失并再次发送，即使接收方为此发送了确认数据包。</p>
<h3 id="tcp-dup-ack-xxx-x" tabindex="-1"> TCP dup ack XXX#X</h3>
<p>标识第几次重新请求某一个包，#前xxx标识第几个包，#后的X标识第几次请求。</p>
<p>TCP dup ack 611#1 ：第一次重新请求第 611 个包。</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261618603.png" alt="image.png" loading="lazy"></p>
<h3 id="tcp-acked-unseen-segment" tabindex="-1"> TCP acked unseen segment</h3>
<p>ACK指向未知的TCP片段。wireshark上反馈是ACK指到不存在的TCP包。很可能是wireshark漏抓了这个包，但却抓到了对端反馈的该报文的ack包。如图。</p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261623318.png" alt="image.png" loading="lazy"></p>
<h3 id="tcp-retransmission" tabindex="-1"> TCP Retransmission</h3>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304261633621.png" alt="image.png" loading="lazy"></p>
<p>TCP超时重传。当同时抓到2次同一数据报文，且没有抓到初传包的反馈ack，wireshark就会判断发生了重传，标记为TCP Retransmission。</p>
<p>如果一个包丢了，又没有后续包可以在接收方触发Dup Ack，或者Dup Ack也丢失的话就不会快速重传。这种情况下发送方只能等到超时再重传。</p>
<h3 id="wireshark-显示过滤器分析" tabindex="-1"> Wireshark 显示过滤器分析</h3>
<p>tcp.analysis.window_full</p>
<p>可以在 wireshark 的显式过滤器中，对这些标志进行过滤。通过 tcp.analysis.tag</p>
<h2 id="wireshark-常用列配置" tabindex="-1"> WireShark 常用列配置</h2>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304241517220.png" alt="image.png" loading="lazy"></p>
<p>如何进行配置的 参考：<a href="https://blog.csdn.net/nuan444979/article/details/126967458?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-126967458-blog-121558664.235%5Ev32%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-126967458-blog-121558664.235%5Ev32%5Epc_relevant_default_base3&amp;utm_relevant_index=6" target="_blank" rel="noopener noreferrer">WireShark 自定义列显式</a></p>
<h1 id="常见问题" tabindex="-1"> 常见问题</h1>
<h2 id="mac-电脑-wireshark-双开" tabindex="-1"> Mac 电脑 Wireshark 双开</h2>
<p>http://www.xiangyuu.cn/%E6%9D%82%E4%B9%B1%E5%B0%8F%E7%AC%94%E8%AE%B0/MacOS%20Wireshark%E6%89%93%E5%BC%80%E5%A4%9A%E7%AA%97%E5%8F%A3.html</p>
<div><pre><code># 打开多个初始Wireshark窗口
open -n /Applications/Wireshark.app

# 直接在多个窗口打开抓包文件
open -n -a /Applications/Wireshark.app file_name.pcap
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="wireshark-恢复默认列配置" tabindex="-1"> Wireshark 恢复默认列配置</h2>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304241548731.png" alt="image.png" loading="lazy"></p>
<p><img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304241548185.png" alt="image.png" loading="lazy">
<img src="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304241549059.png" alt="image.png" loading="lazy"></p>
<p>删除 profiles 以外的全部文件</p>
]]></content:encoded>
      <enclosure url="https://ljd-image-upload.oss-cn-beijing.aliyuncs.com/sources/202304251434170.png" type="image/png"/>
    </item>
  </channel>
</rss>